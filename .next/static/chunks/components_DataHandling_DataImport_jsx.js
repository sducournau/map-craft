/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["components_DataHandling_DataImport_jsx"],{

/***/ "./components/DataHandling/DataImport.jsx":
/*!************************************************!*\
  !*** ./components/DataHandling/DataImport.jsx ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("const handleFileUpload = useCallback(async (event)=>{\n    var _event_target_files;\n    const file = (_event_target_files = event.target.files) === null || _event_target_files === void 0 ? void 0 : _event_target_files[0];\n    if (!file) return;\n    setLoading(true);\n    setError(null);\n    try {\n        var _file_name_split_pop;\n        // Validate file size\n        if (file.size > 50 * 1024 * 1024) {\n            throw new Error(\"Le fichier est trop volumineux (limite de 50MB)\");\n        }\n        const fileExtension = (_file_name_split_pop = file.name.split(\".\").pop()) === null || _file_name_split_pop === void 0 ? void 0 : _file_name_split_pop.toLowerCase();\n        // Validate supported file extensions\n        if (![\n            \"geojson\",\n            \"json\",\n            \"csv\",\n            \"gpkg\",\n            \"zip\"\n        ].includes(fileExtension)) {\n            throw new Error(\"Format de fichier non support\\xe9: \".concat(fileExtension, \". Formats accept\\xe9s: GeoJSON, CSV, GeoPackage, Shapefile (ZIP)\"));\n        }\n        const reader = new FileReader();\n        // Set up promise-based file reader\n        const readFilePromise = new Promise((resolve, reject)=>{\n            reader.onload = (e)=>resolve(e.target.result);\n            reader.onerror = (e)=>reject(new Error(\"Erreur lors de la lecture du fichier\"));\n        });\n        // Start reading the file\n        if (fileExtension === \"csv\") {\n            reader.readAsText(file);\n        } else {\n            reader.readAsArrayBuffer(file);\n        }\n        // Wait for file to be read\n        const result = await readFilePromise;\n        // Process file based on its type\n        let data;\n        if (fileExtension === \"geojson\" || fileExtension === \"json\") {\n            try {\n                // Handle GeoJSON\n                data = JSON.parse(result);\n                data = formatGeoJson(data);\n                // Basic validation\n                if (!data.type || data.type !== \"FeatureCollection\" || !Array.isArray(data.features)) {\n                    throw new Error(\"Format GeoJSON invalide\");\n                }\n            } catch (parseError) {\n                throw new Error(\"Erreur de parsing JSON: \".concat(parseError.message));\n            }\n        } else if (fileExtension === \"csv\") {\n            // Handle CSV with custom options if provided\n            try {\n                data = csvToGeoJson(result, dataType === \"auto\" ? {} : customOptions);\n                // Check if any features were created\n                if (!data.features || data.features.length === 0) {\n                    throw new Error(\"Aucune donn\\xe9e g\\xe9ospatiale n'a pu \\xeatre extraite du CSV\");\n                }\n            } catch (csvError) {\n                throw new Error(\"Erreur lors de la conversion du CSV: \".concat(csvError.message));\n            }\n        } else if (fileExtension === \"gpkg\") {\n            // Handle GeoPackage\n            try {\n                data = await processGeoPackage(file);\n            } catch (gpkgError) {\n                throw new Error(\"Erreur lors du traitement du GeoPackage: \".concat(gpkgError.message));\n            }\n        } else if (fileExtension === \"zip\") {\n            // Handle Shapefile in ZIP\n            try {\n                data = await processShapefile(result);\n            } catch (shpError) {\n                throw new Error(\"Erreur lors du traitement du Shapefile: \".concat(shpError.message));\n            }\n        }\n        // Final validation\n        if (!data || !data.features || data.features.length === 0) {\n            throw new Error(\"Aucune donn\\xe9e valide n'a \\xe9t\\xe9 trouv\\xe9e dans le fichier\");\n        }\n        onDataImported(data);\n        if (onClose) onClose();\n    } catch (err) {\n        console.error(\"Error processing file:\", err);\n        setError(\"Erreur: \".concat(err.message));\n    } finally{\n        setLoading(false);\n    }\n}, [\n    onDataImported,\n    onClose,\n    dataType,\n    customOptions\n]);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0RhdGFIYW5kbGluZy9EYXRhSW1wb3J0LmpzeCIsIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxtQkFBbUJDLFlBQVksT0FBT0M7UUFDN0JBO0lBQWIsTUFBTUMsUUFBT0Qsc0JBQUFBLE1BQU1FLE1BQU0sQ0FBQ0MsS0FBSyxjQUFsQkgsMENBQUFBLG1CQUFvQixDQUFDLEVBQUU7SUFDcEMsSUFBSSxDQUFDQyxNQUFNO0lBRVhHLFdBQVc7SUFDWEMsU0FBUztJQUVULElBQUk7WUFNb0JKO1FBTHRCLHFCQUFxQjtRQUNyQixJQUFJQSxLQUFLSyxJQUFJLEdBQUcsS0FBSyxPQUFPLE1BQU07WUFDaEMsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBRUEsTUFBTUMsaUJBQWdCUCx1QkFBQUEsS0FBS1EsSUFBSSxDQUFDQyxLQUFLLENBQUMsS0FBS0MsR0FBRyxnQkFBeEJWLDJDQUFBQSxxQkFBNEJXLFdBQVc7UUFFN0QscUNBQXFDO1FBQ3JDLElBQUksQ0FBQztZQUFDO1lBQVc7WUFBUTtZQUFPO1lBQVE7U0FBTSxDQUFDQyxRQUFRLENBQUNMLGdCQUFnQjtZQUN0RSxNQUFNLElBQUlELE1BQU0sc0NBQWlELE9BQWRDLGVBQWM7UUFDbkU7UUFFQSxNQUFNTSxTQUFTLElBQUlDO1FBRW5CLG1DQUFtQztRQUNuQyxNQUFNQyxrQkFBa0IsSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztZQUM1Q0wsT0FBT00sTUFBTSxHQUFHLENBQUNDLElBQU1ILFFBQVFHLEVBQUVuQixNQUFNLENBQUNvQixNQUFNO1lBQzlDUixPQUFPUyxPQUFPLEdBQUcsQ0FBQ0YsSUFBTUYsT0FBTyxJQUFJWixNQUFNO1FBQzNDO1FBRUEseUJBQXlCO1FBQ3pCLElBQUlDLGtCQUFrQixPQUFPO1lBQzNCTSxPQUFPVSxVQUFVLENBQUN2QjtRQUNwQixPQUFPO1lBQ0xhLE9BQU9XLGlCQUFpQixDQUFDeEI7UUFDM0I7UUFFQSwyQkFBMkI7UUFDM0IsTUFBTXFCLFNBQVMsTUFBTU47UUFFckIsaUNBQWlDO1FBQ2pDLElBQUlVO1FBQ0osSUFBSWxCLGtCQUFrQixhQUFhQSxrQkFBa0IsUUFBUTtZQUMzRCxJQUFJO2dCQUNGLGlCQUFpQjtnQkFDakJrQixPQUFPQyxLQUFLQyxLQUFLLENBQUNOO2dCQUNsQkksT0FBT0csY0FBY0g7Z0JBRXJCLG1CQUFtQjtnQkFDbkIsSUFBSSxDQUFDQSxLQUFLSSxJQUFJLElBQUlKLEtBQUtJLElBQUksS0FBSyx1QkFBdUIsQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDTixLQUFLTyxRQUFRLEdBQUc7b0JBQ3BGLE1BQU0sSUFBSTFCLE1BQU07Z0JBQ2xCO1lBQ0YsRUFBRSxPQUFPMkIsWUFBWTtnQkFDbkIsTUFBTSxJQUFJM0IsTUFBTSwyQkFBOEMsT0FBbkIyQixXQUFXQyxPQUFPO1lBQy9EO1FBQ0YsT0FBTyxJQUFJM0Isa0JBQWtCLE9BQU87WUFDbEMsNkNBQTZDO1lBQzdDLElBQUk7Z0JBQ0ZrQixPQUFPVSxhQUFhZCxRQUFRZSxhQUFhLFNBQVMsQ0FBQyxJQUFJQztnQkFFdkQscUNBQXFDO2dCQUNyQyxJQUFJLENBQUNaLEtBQUtPLFFBQVEsSUFBSVAsS0FBS08sUUFBUSxDQUFDTSxNQUFNLEtBQUssR0FBRztvQkFDaEQsTUFBTSxJQUFJaEMsTUFBTTtnQkFDbEI7WUFDRixFQUFFLE9BQU9pQyxVQUFVO2dCQUNqQixNQUFNLElBQUlqQyxNQUFNLHdDQUF5RCxPQUFqQmlDLFNBQVNMLE9BQU87WUFDMUU7UUFDRixPQUFPLElBQUkzQixrQkFBa0IsUUFBUTtZQUNuQyxvQkFBb0I7WUFDcEIsSUFBSTtnQkFDRmtCLE9BQU8sTUFBTWUsa0JBQWtCeEM7WUFDakMsRUFBRSxPQUFPeUMsV0FBVztnQkFDbEIsTUFBTSxJQUFJbkMsTUFBTSw0Q0FBOEQsT0FBbEJtQyxVQUFVUCxPQUFPO1lBQy9FO1FBQ0YsT0FBTyxJQUFJM0Isa0JBQWtCLE9BQU87WUFDbEMsMEJBQTBCO1lBQzFCLElBQUk7Z0JBQ0ZrQixPQUFPLE1BQU1pQixpQkFBaUJyQjtZQUNoQyxFQUFFLE9BQU9zQixVQUFVO2dCQUNqQixNQUFNLElBQUlyQyxNQUFNLDJDQUE0RCxPQUFqQnFDLFNBQVNULE9BQU87WUFDN0U7UUFDRjtRQUVBLG1CQUFtQjtRQUNuQixJQUFJLENBQUNULFFBQVEsQ0FBQ0EsS0FBS08sUUFBUSxJQUFJUCxLQUFLTyxRQUFRLENBQUNNLE1BQU0sS0FBSyxHQUFHO1lBQ3pELE1BQU0sSUFBSWhDLE1BQU07UUFDbEI7UUFFQXNDLGVBQWVuQjtRQUNmLElBQUlvQixTQUFTQTtJQUNmLEVBQUUsT0FBT0MsS0FBSztRQUNaQyxRQUFRQyxLQUFLLENBQUMsMEJBQTBCRjtRQUN4QzFDLFNBQVMsV0FBdUIsT0FBWjBDLElBQUlaLE9BQU87SUFDakMsU0FBVTtRQUNSL0IsV0FBVztJQUNiO0FBQ0YsR0FBRztJQUFDeUM7SUFBZ0JDO0lBQVNUO0lBQVVDO0NBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9EYXRhSGFuZGxpbmcvRGF0YUltcG9ydC5qc3g/YjU4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBoYW5kbGVGaWxlVXBsb2FkID0gdXNlQ2FsbGJhY2soYXN5bmMgKGV2ZW50KSA9PiB7XHJcbiAgY29uc3QgZmlsZSA9IGV2ZW50LnRhcmdldC5maWxlcz8uWzBdO1xyXG4gIGlmICghZmlsZSkgcmV0dXJuO1xyXG5cclxuICBzZXRMb2FkaW5nKHRydWUpO1xyXG4gIHNldEVycm9yKG51bGwpO1xyXG5cclxuICB0cnkge1xyXG4gICAgLy8gVmFsaWRhdGUgZmlsZSBzaXplXHJcbiAgICBpZiAoZmlsZS5zaXplID4gNTAgKiAxMDI0ICogMTAyNCkgeyAvLyA1ME1CIGxpbWl0XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTGUgZmljaGllciBlc3QgdHJvcCB2b2x1bWluZXV4IChsaW1pdGUgZGUgNTBNQiknKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBmaWxlRXh0ZW5zaW9uID0gZmlsZS5uYW1lLnNwbGl0KCcuJykucG9wKCk/LnRvTG93ZXJDYXNlKCk7XHJcbiAgICBcclxuICAgIC8vIFZhbGlkYXRlIHN1cHBvcnRlZCBmaWxlIGV4dGVuc2lvbnNcclxuICAgIGlmICghWydnZW9qc29uJywgJ2pzb24nLCAnY3N2JywgJ2dwa2cnLCAnemlwJ10uaW5jbHVkZXMoZmlsZUV4dGVuc2lvbikpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JtYXQgZGUgZmljaGllciBub24gc3VwcG9ydMOpOiAke2ZpbGVFeHRlbnNpb259LiBGb3JtYXRzIGFjY2VwdMOpczogR2VvSlNPTiwgQ1NWLCBHZW9QYWNrYWdlLCBTaGFwZWZpbGUgKFpJUClgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG5cclxuICAgIC8vIFNldCB1cCBwcm9taXNlLWJhc2VkIGZpbGUgcmVhZGVyXHJcbiAgICBjb25zdCByZWFkRmlsZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHJlYWRlci5vbmxvYWQgPSAoZSkgPT4gcmVzb2x2ZShlLnRhcmdldC5yZXN1bHQpO1xyXG4gICAgICByZWFkZXIub25lcnJvciA9IChlKSA9PiByZWplY3QobmV3IEVycm9yKCdFcnJldXIgbG9ycyBkZSBsYSBsZWN0dXJlIGR1IGZpY2hpZXInKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBTdGFydCByZWFkaW5nIHRoZSBmaWxlXHJcbiAgICBpZiAoZmlsZUV4dGVuc2lvbiA9PT0gJ2NzdicpIHtcclxuICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV2FpdCBmb3IgZmlsZSB0byBiZSByZWFkXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkRmlsZVByb21pc2U7XHJcblxyXG4gICAgLy8gUHJvY2VzcyBmaWxlIGJhc2VkIG9uIGl0cyB0eXBlXHJcbiAgICBsZXQgZGF0YTtcclxuICAgIGlmIChmaWxlRXh0ZW5zaW9uID09PSAnZ2VvanNvbicgfHwgZmlsZUV4dGVuc2lvbiA9PT0gJ2pzb24nKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gSGFuZGxlIEdlb0pTT05cclxuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShyZXN1bHQpO1xyXG4gICAgICAgIGRhdGEgPSBmb3JtYXRHZW9Kc29uKGRhdGEpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEJhc2ljIHZhbGlkYXRpb25cclxuICAgICAgICBpZiAoIWRhdGEudHlwZSB8fCBkYXRhLnR5cGUgIT09ICdGZWF0dXJlQ29sbGVjdGlvbicgfHwgIUFycmF5LmlzQXJyYXkoZGF0YS5mZWF0dXJlcykpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybWF0IEdlb0pTT04gaW52YWxpZGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycmV1ciBkZSBwYXJzaW5nIEpTT046ICR7cGFyc2VFcnJvci5tZXNzYWdlfWApO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGZpbGVFeHRlbnNpb24gPT09ICdjc3YnKSB7XHJcbiAgICAgIC8vIEhhbmRsZSBDU1Ygd2l0aCBjdXN0b20gb3B0aW9ucyBpZiBwcm92aWRlZFxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGRhdGEgPSBjc3ZUb0dlb0pzb24ocmVzdWx0LCBkYXRhVHlwZSA9PT0gJ2F1dG8nID8ge30gOiBjdXN0b21PcHRpb25zKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDaGVjayBpZiBhbnkgZmVhdHVyZXMgd2VyZSBjcmVhdGVkXHJcbiAgICAgICAgaWYgKCFkYXRhLmZlYXR1cmVzIHx8IGRhdGEuZmVhdHVyZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1Y3VuZSBkb25uw6llIGfDqW9zcGF0aWFsZSBuXFwnYSBwdSDDqnRyZSBleHRyYWl0ZSBkdSBDU1YnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGNzdkVycm9yKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJldXIgbG9ycyBkZSBsYSBjb252ZXJzaW9uIGR1IENTVjogJHtjc3ZFcnJvci5tZXNzYWdlfWApO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGZpbGVFeHRlbnNpb24gPT09ICdncGtnJykge1xyXG4gICAgICAvLyBIYW5kbGUgR2VvUGFja2FnZVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGRhdGEgPSBhd2FpdCBwcm9jZXNzR2VvUGFja2FnZShmaWxlKTtcclxuICAgICAgfSBjYXRjaCAoZ3BrZ0Vycm9yKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJldXIgbG9ycyBkdSB0cmFpdGVtZW50IGR1IEdlb1BhY2thZ2U6ICR7Z3BrZ0Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoZmlsZUV4dGVuc2lvbiA9PT0gJ3ppcCcpIHtcclxuICAgICAgLy8gSGFuZGxlIFNoYXBlZmlsZSBpbiBaSVBcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBkYXRhID0gYXdhaXQgcHJvY2Vzc1NoYXBlZmlsZShyZXN1bHQpO1xyXG4gICAgICB9IGNhdGNoIChzaHBFcnJvcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyZXVyIGxvcnMgZHUgdHJhaXRlbWVudCBkdSBTaGFwZWZpbGU6ICR7c2hwRXJyb3IubWVzc2FnZX1gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZpbmFsIHZhbGlkYXRpb25cclxuICAgIGlmICghZGF0YSB8fCAhZGF0YS5mZWF0dXJlcyB8fCBkYXRhLmZlYXR1cmVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1Y3VuZSBkb25uw6llIHZhbGlkZSBuXFwnYSDDqXTDqSB0cm91dsOpZSBkYW5zIGxlIGZpY2hpZXInKTtcclxuICAgIH1cclxuXHJcbiAgICBvbkRhdGFJbXBvcnRlZChkYXRhKTtcclxuICAgIGlmIChvbkNsb3NlKSBvbkNsb3NlKCk7XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwcm9jZXNzaW5nIGZpbGU6JywgZXJyKTtcclxuICAgIHNldEVycm9yKGBFcnJldXI6ICR7ZXJyLm1lc3NhZ2V9YCk7XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gIH1cclxufSwgW29uRGF0YUltcG9ydGVkLCBvbkNsb3NlLCBkYXRhVHlwZSwgY3VzdG9tT3B0aW9uc10pOyJdLCJuYW1lcyI6WyJoYW5kbGVGaWxlVXBsb2FkIiwidXNlQ2FsbGJhY2siLCJldmVudCIsImZpbGUiLCJ0YXJnZXQiLCJmaWxlcyIsInNldExvYWRpbmciLCJzZXRFcnJvciIsInNpemUiLCJFcnJvciIsImZpbGVFeHRlbnNpb24iLCJuYW1lIiwic3BsaXQiLCJwb3AiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsInJlYWRGaWxlUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwib25sb2FkIiwiZSIsInJlc3VsdCIsIm9uZXJyb3IiLCJyZWFkQXNUZXh0IiwicmVhZEFzQXJyYXlCdWZmZXIiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwiZm9ybWF0R2VvSnNvbiIsInR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJmZWF0dXJlcyIsInBhcnNlRXJyb3IiLCJtZXNzYWdlIiwiY3N2VG9HZW9Kc29uIiwiZGF0YVR5cGUiLCJjdXN0b21PcHRpb25zIiwibGVuZ3RoIiwiY3N2RXJyb3IiLCJwcm9jZXNzR2VvUGFja2FnZSIsImdwa2dFcnJvciIsInByb2Nlc3NTaGFwZWZpbGUiLCJzaHBFcnJvciIsIm9uRGF0YUltcG9ydGVkIiwib25DbG9zZSIsImVyciIsImNvbnNvbGUiLCJlcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/DataHandling/DataImport.jsx\n"));

/***/ })

}]);